{"version":3,"sources":["../src/user.ts","../src/university.ts","../src/campus.ts","../src/livingspace.ts","../src/pricing.ts","../src/address.ts"],"sourcesContent":["import * as z from \"zod\"\n\nexport const userSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string(),\n})\n","import * as z from \"zod\"\nimport { CompleteCampus, relatedCampusSchema } from \"./index\"\n\nexport const universitySchema = z.object({\n  id: z.string(),\n  name: z.string(),\n})\n\nexport interface CompleteUniversity extends z.infer<typeof universitySchema> {\n  campuses: CompleteCampus[]\n}\n\n/**\n * relatedUniversitySchema contains all relations on your model in addition to the scalars\n *\n * NOTE: Lazy required in case of potential circular dependencies within schema\n */\nexport const relatedUniversitySchema: z.ZodSchema<CompleteUniversity> = z.lazy(() => universitySchema.extend({\n  campuses: relatedCampusSchema.array(),\n}))\n","import * as z from \"zod\"\nimport { CompleteAddress, relatedAddressSchema, CompleteUniversity, relatedUniversitySchema, CompleteLivingSpace, relatedLivingSpaceSchema } from \"./index\"\n\nexport const campusSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  addressId: z.string(),\n  universityId: z.string(),\n})\n\nexport interface CompleteCampus extends z.infer<typeof campusSchema> {\n  address: CompleteAddress\n  university: CompleteUniversity\n  livingSpaces: CompleteLivingSpace[]\n}\n\n/**\n * relatedCampusSchema contains all relations on your model in addition to the scalars\n *\n * NOTE: Lazy required in case of potential circular dependencies within schema\n */\nexport const relatedCampusSchema: z.ZodSchema<CompleteCampus> = z.lazy(() => campusSchema.extend({\n  address: relatedAddressSchema,\n  university: relatedUniversitySchema,\n  livingSpaces: relatedLivingSpaceSchema.array(),\n}))\n","import * as z from \"zod\"\nimport { CompleteAddress, relatedAddressSchema, CompleteCampus, relatedCampusSchema, CompletePricing, relatedPricingSchema } from \"./index\"\n\nexport const livingSpaceSchema = z.object({\n  id: z.string(),\n  placeId: z.string(),\n  name: z.string(),\n  website: z.string().nullish(),\n  phone: z.string().nullish(),\n  photoUrl: z.string().nullish(),\n  photoAttributions: z.string().array(),\n  mapsUrl: z.string(),\n  type: z.string(),\n  addressId: z.string(),\n  campusId: z.string(),\n})\n\nexport interface CompleteLivingSpace extends z.infer<typeof livingSpaceSchema> {\n  address: CompleteAddress\n  campus: CompleteCampus\n  pricings: CompletePricing[]\n}\n\n/**\n * relatedLivingSpaceSchema contains all relations on your model in addition to the scalars\n *\n * NOTE: Lazy required in case of potential circular dependencies within schema\n */\nexport const relatedLivingSpaceSchema: z.ZodSchema<CompleteLivingSpace> = z.lazy(() => livingSpaceSchema.extend({\n  address: relatedAddressSchema,\n  campus: relatedCampusSchema,\n  pricings: relatedPricingSchema.array(),\n}))\n","import * as z from \"zod\"\nimport { CompleteLivingSpace, relatedLivingSpaceSchema } from \"./index\"\n\nexport const pricingSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  price: z.number(),\n  livingSpaceId: z.string(),\n})\n\nexport interface CompletePricing extends z.infer<typeof pricingSchema> {\n  livingSpace: CompleteLivingSpace\n}\n\n/**\n * relatedPricingSchema contains all relations on your model in addition to the scalars\n *\n * NOTE: Lazy required in case of potential circular dependencies within schema\n */\nexport const relatedPricingSchema: z.ZodSchema<CompletePricing> = z.lazy(() => pricingSchema.extend({\n  livingSpace: relatedLivingSpaceSchema,\n}))\n","import * as z from \"zod\"\nimport { CompleteCampus, relatedCampusSchema, CompleteLivingSpace, relatedLivingSpaceSchema } from \"./index\"\n\nexport const addressSchema = z.object({\n  id: z.string(),\n  street: z.string(),\n  city: z.string(),\n  state: z.string(),\n  zip: z.string(),\n  latitude: z.number(),\n  longitude: z.number(),\n})\n\nexport interface CompleteAddress extends z.infer<typeof addressSchema> {\n  campuses: CompleteCampus[]\n  livingSpaces: CompleteLivingSpace[]\n}\n\n/**\n * relatedAddressSchema contains all relations on your model in addition to the scalars\n *\n * NOTE: Lazy required in case of potential circular dependencies within schema\n */\nexport const relatedAddressSchema: z.ZodSchema<CompleteAddress> = z.lazy(() => addressSchema.extend({\n  campuses: relatedCampusSchema.array(),\n  livingSpaces: relatedLivingSpaceSchema.array(),\n}))\n"],"mappings":";AAAA,YAAY,OAAO;AAEZ,IAAM,aAAe,SAAO;AAAA,EACjC,IAAM,SAAO;AAAA,EACb,MAAQ,SAAO;AAAA,EACf,OAAS,SAAO;AAClB,CAAC;;;ACND,YAAYA,QAAO;AAGZ,IAAM,mBAAqB,UAAO;AAAA,EACvC,IAAM,UAAO;AAAA,EACb,MAAQ,UAAO;AACjB,CAAC;AAWM,IAAM,0BAA6D,QAAK,MAAM,iBAAiB,OAAO;AAAA,EAC3G,UAAU,oBAAoB,MAAM;AACtC,CAAC,CAAC;;;ACnBF,YAAYC,QAAO;AAGZ,IAAM,eAAiB,UAAO;AAAA,EACnC,IAAM,UAAO;AAAA,EACb,MAAQ,UAAO;AAAA,EACf,WAAa,UAAO;AAAA,EACpB,cAAgB,UAAO;AACzB,CAAC;AAaM,IAAM,sBAAqD,QAAK,MAAM,aAAa,OAAO;AAAA,EAC/F,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,cAAc,yBAAyB,MAAM;AAC/C,CAAC,CAAC;;;ACzBF,YAAYC,QAAO;AAGZ,IAAM,oBAAsB,UAAO;AAAA,EACxC,IAAM,UAAO;AAAA,EACb,SAAW,UAAO;AAAA,EAClB,MAAQ,UAAO;AAAA,EACf,SAAW,UAAO,EAAE,QAAQ;AAAA,EAC5B,OAAS,UAAO,EAAE,QAAQ;AAAA,EAC1B,UAAY,UAAO,EAAE,QAAQ;AAAA,EAC7B,mBAAqB,UAAO,EAAE,MAAM;AAAA,EACpC,SAAW,UAAO;AAAA,EAClB,MAAQ,UAAO;AAAA,EACf,WAAa,UAAO;AAAA,EACpB,UAAY,UAAO;AACrB,CAAC;AAaM,IAAM,2BAA+D,QAAK,MAAM,kBAAkB,OAAO;AAAA,EAC9G,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,UAAU,qBAAqB,MAAM;AACvC,CAAC,CAAC;;;AChCF,YAAYC,QAAO;AAGZ,IAAM,gBAAkB,UAAO;AAAA,EACpC,IAAM,UAAO;AAAA,EACb,MAAQ,UAAO;AAAA,EACf,OAAS,UAAO;AAAA,EAChB,eAAiB,UAAO;AAC1B,CAAC;AAWM,IAAM,uBAAuD,QAAK,MAAM,cAAc,OAAO;AAAA,EAClG,aAAa;AACf,CAAC,CAAC;;;ACrBF,YAAYC,QAAO;AAGZ,IAAM,gBAAkB,UAAO;AAAA,EACpC,IAAM,UAAO;AAAA,EACb,QAAU,UAAO;AAAA,EACjB,MAAQ,UAAO;AAAA,EACf,OAAS,UAAO;AAAA,EAChB,KAAO,UAAO;AAAA,EACd,UAAY,UAAO;AAAA,EACnB,WAAa,UAAO;AACtB,CAAC;AAYM,IAAM,uBAAuD,QAAK,MAAM,cAAc,OAAO;AAAA,EAClG,UAAU,oBAAoB,MAAM;AAAA,EACpC,cAAc,yBAAyB,MAAM;AAC/C,CAAC,CAAC;","names":["z","z","z","z","z"]}